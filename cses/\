#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define endl '\n'
#define AI(x) begin(x),end(x)
#ifdef DEBUG 
#define debug(args...) LKJ("\033[1;32m[ "+string(#args)+" ]\033[0m", args)
template<class I> void LKJ(I&&x){ cerr << x << '\n'; }
template<class I, class...T> void LKJ(I&&x, T&&...t){ cerr << x << ", ", LKJ(t...); }
template<class I> void OI(I a, I b){ while(a < b) cerr << *a << " \n"[next(a) == b], ++a; }
#else
#define debug(...) 0
#define OI(...) 0
#endif
#define _ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define int long long

struct SegmentTree {
	struct node {
		int val = 0;
		int tag = 0;
		void add(int v) {
			debug(v);
			val+=v;
			tag+=v;
		}
	};

	vector<node> st;
	int n;
	
	SegmentTree (int _n, vector<int> arr) {
		n = _n;
		st.resize(2*n+5);
		for (int i = 0; i < n; ++i) {
			st[i+n].val = arr[i];
		}
		for (int i = n-1; i > 0; --i) {
			st[i].val = max(st[i<<1].val, st[i<<1^1].val);
		}
	}
	
	void pull(int x) {
		if (x == 1) return;
		pull(x >>= 1);
		if (!st[x>>1].tag) return;
		st[x].add(st[x>>1].tag);
		st[x^1].add(st[x>>1].tag);
		st[x>>1].tag = 0;
		return;
	}
	
	void push(int i) {
		i >>= 1;
		while (i > 0) {
			st[i].val = max(st[i<<1].val, st[i<<1^1].val);
			i >>= 1;
		}
	}	
	
	int query(int ql, int qr) {
		int l = ql, r = qr;
		pull(ql); pull(qr);
		int mx = INT_MIN;
		while (l < r) {
			if (l & 1) mx = max(mx, st[l++].val);
			if (r & 1) mx = max(mx, st[--r].val);
			l >>= 1; r >>= 1;
		}
		return mx;
	}

	void modify(int ql, int qr, int v) {
		int l = ql; int r = qr;
		pull(ql); pull(qr);
		while (l < r) {
			if (l & 1) st[l++].add(v);
			if (r & 1) st[--r].add(v);
			l >>= 1; r >>= 1;
		}
		push(ql); push(qr);
		for (int i = 1; i < 2*n; ++i) debug(i, st[i].val);
	}
};

struct BIT {
	int n;
	vector<int> arr;
	void modify(int i, int v) {
		for (i; i <= n; i += (i&-i)) {
			arr[i] += v;
		}
	}
	
	int query(int i) {
		int ans = 0;
		for (i; i > 0; i -=(i&-i)) {
			ans += arr[i];
		}
		return ans;
	}

	BIT(int _n, const vector<int> & s) {
		n = _n;
		arr.resize(n+5);
		for (int i = 1; i <= n; ++i) {
			modify(i, s[i]);
		}
	}
};

signed main(){_
	int n, q;
	cin >> n >> q;
	vector<int> arr(n+1);
	vector<int> pre(n+1);
	for (int i = 1; i <= n; ++i) {
		cin >> arr[i];
		pre[i] = arr[i] + pre[i-1];
	}	

	SegmentTree st(n+1, pre);
	BIT bit(n+1, pre);
	OI(AI(pre));

	while (q--) {
		int tp;
		cin >> tp;
		if (tp == 1) {
			int k, u;
			cin >> k >> u;
			debug(u-arr[k]);
			st.modify(k, n+1, u - arr[k]);
			bit.modify(k, u-arr[k]);
		   	arr[k] = u;	
		}
		else {
			int a, b;
			cin >> a >> b;
			debug(st.query(a, b+1));
			cout << st.query(a, b+1) - bit.query(a-1) << endl;
		}
	}	
	return 0;
}
